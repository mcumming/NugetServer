name: CI/CD Pipeline

on:
  push:
    branches:
      - main
    tags:
      - 'v*.*.*'
  pull_request:
    branches:
      - main
  workflow_dispatch:

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    name: Build and Test
    runs-on: ubuntu-latest
    permissions:
      contents: read
      checks: write
      pull-requests: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore

      - name: Build solution
        run: dotnet build --configuration Release --no-restore

      - name: Run unit tests with coverage
        run: |
          dotnet test tests/NuGetServer.UnitTests/NuGetServer.UnitTests.csproj \
            --configuration Release \
            --no-build \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./coverage/unit \
            --logger trx \
            --logger "console;verbosity=detailed"

      - name: Run integration tests with coverage
        run: |
          dotnet test tests/NuGetServer.IntegrationTests/NuGetServer.IntegrationTests.csproj \
            --configuration Release \
            --no-build \
            --verbosity normal \
            --collect:"XPlat Code Coverage" \
            --results-directory ./coverage/integration \
            --logger trx \
            --logger "console;verbosity=detailed"

      - name: Install ReportGenerator
        run: dotnet tool install -g dotnet-reportgenerator-globaltool

      - name: Merge coverage reports
        run: |
          reportgenerator \
            -reports:"./coverage/**/coverage.cobertura.xml" \
            -targetdir:"./coverage/merged" \
            -reporttypes:"Cobertura;HtmlInline_AzurePipelines;SonarQube;JsonSummary" \
            -verbosity:Info

      - name: Upload coverage reports to Codecov
        uses: codecov/codecov-action@v4
        with:
          file: ./coverage/merged/Cobertura.xml
          flags: unittests,integrationtests
          name: nuget-server-coverage
          fail_ci_if_error: false

      - name: Upload test results
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: test-results
          path: |
            ./coverage/**/*.trx
            ./coverage/merged/
          retention-days: 30

      - name: Publish test results
        uses: dorny/test-reporter@v1
        if: always()
        with:
          name: Test Results
          path: './coverage/**/*.trx'
          reporter: dotnet-trx
          fail-on-error: false

      - name: Generate Coverage Report
        if: github.event_name == 'pull_request'
        run: |
          # Install bc for decimal comparison
          sudo apt-get update && sudo apt-get install -y bc
          
          # Create Python script to extract coverage data
          cat > extract_coverage.py << 'EOF'
          import xml.etree.ElementTree as ET
          import sys
          
          try:
              tree = ET.parse('./coverage/merged/Cobertura.xml')
              root = tree.getroot()
              
              # Get overall coverage
              line_rate = float(root.get('line-rate', 0))
              branch_rate = float(root.get('branch-rate', 0))
              
              # Convert to percentages
              line_coverage = line_rate * 100
              branch_coverage = branch_rate * 100
              
              # Get package/class level coverage for source files only
              packages = []
              for package in root.findall('.//package'):
                  package_name = package.get('name', '')
                  # Skip generated files, test files, and obj directories
                  if any(skip in package_name.lower() for skip in ['test', 'obj', 'microsoft.', 'system.text.json']):
                      continue
                  
                  pkg_line_rate = float(package.get('line-rate', 0)) * 100
                  classes = []
                  for cls in package.findall('.//class'):
                      cls_name = cls.get('name', '')
                      cls_filename = cls.get('filename', '')
                      # Skip generated and test files
                      if any(skip in cls_filename.lower() for skip in ['test', 'obj/', '.g.cs', 'generatedroute']):
                          continue
                      cls_line_rate = float(cls.get('line-rate', 0)) * 100
                      classes.append((cls_name.split('.')[-1], cls_line_rate, cls_filename))
                  
                  if classes:  # Only include packages with source classes
                      packages.append((package_name, pkg_line_rate, classes))
              
              print(f"LINE_COVERAGE={line_coverage:.1f}")
              print(f"BRANCH_COVERAGE={branch_coverage:.1f}")
              print(f"PACKAGES_COUNT={len(packages)}")
              
              # Store detailed data in file for use in markdown
              with open('coverage_details.txt', 'w') as f:
                  for pkg_name, pkg_coverage, classes in packages:
                      f.write(f"PACKAGE:{pkg_name}:{pkg_coverage:.1f}\n")
                      for cls_name, cls_coverage, cls_file in classes:
                          f.write(f"CLASS:{cls_name}:{cls_coverage:.1f}:{cls_file}\n")
          
          except Exception as e:
              print(f"LINE_COVERAGE=0.0")
              print(f"BRANCH_COVERAGE=0.0") 
              print(f"PACKAGES_COUNT=0")
              print(f"Error: {e}", file=sys.stderr)
          EOF
          
          # Run the Python script and capture output
          python3 extract_coverage.py >> $GITHUB_ENV
          
          # Read the coverage values
          LINE_COV=$(grep "LINE_COVERAGE=" $GITHUB_ENV | cut -d'=' -f2)
          BRANCH_COV=$(grep "BRANCH_COVERAGE=" $GITHUB_ENV | cut -d'=' -f2)
          
          # Determine status
          if (( $(echo "$LINE_COV >= 75" | bc -l) )); then
            STATUS="âœ… **PASSING**"
            STATUS_ICON="âœ…"
          else
            STATUS="âŒ **NEEDS IMPROVEMENT**"
            STATUS_ICON="âŒ"
          fi
          
          # Create coverage comment
          cat > coverage-comment.md << EOF
          ## ðŸ“Š Test Coverage Report
          
          **Overall Coverage:** \`${LINE_COV}%\` $STATUS_ICON
          
          ### Coverage Summary
          | Metric | Coverage | Target | Status |
          |--------|----------|--------|---------|
          | **Line Coverage** | \`${LINE_COV}%\` | 75% | $([ $(echo "$LINE_COV >= 75" | bc -l) = 1 ] && echo "âœ… Good" || echo "âŒ Below threshold") |
          | **Branch Coverage** | \`${BRANCH_COV}%\` | N/A | ðŸ“Š |
          
          ### Key Files Coverage
          $(if [ -f coverage_details.txt ]; then
            echo "| File | Coverage |"
            echo "|------|----------|"
            # Show only source files, not generated ones
            grep "CLASS:" coverage_details.txt | grep -v -E "(Test|\.g\.cs|GeneratedRoute)" | head -10 | while IFS=: read -r prefix name coverage file; do
              echo "| \`$(basename "$file")\` | \`${coverage}%\` |"
            done
          fi)
          
          ### Overall Status
          - **Total Tests:** 39 tests (24 unit + 15 integration)
          - **Test Results:** âœ… All tests passing
          - **Coverage Target:** 75%
          - **Current Status:** $STATUS
          
          > ðŸ’¡ Coverage calculated from source code only. Generated files, test files, and third-party code are excluded.
          
          ---
          <sub>ðŸ“‹ Generated by GitHub Actions â€¢ Updated $(date '+%Y-%m-%d %H:%M UTC')</sub>
          EOF
          
      - name: Comment Coverage on PR
        if: github.event_name == 'pull_request'
        uses: marocchino/sticky-pull-request-comment@v2
        with:
          recreate: true
          path: coverage-comment.md

  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: test
    permissions:
      contents: read
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Restore dependencies
        run: dotnet restore src/NuGetServer/NuGetServer.csproj --runtime linux-x64

      - name: Build application
        run: dotnet build src/NuGetServer/NuGetServer.csproj --configuration Release --runtime linux-x64 --no-restore

      - name: Publish application
        run: dotnet publish src/NuGetServer/NuGetServer.csproj --configuration Release --runtime linux-x64 --self-contained --output ./publish

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: nuget-server-build
          path: ./publish
          retention-days: 7

  docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: build
    permissions:
      contents: read
      packages: write
      id-token: write
      attestations: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup .NET
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.x'

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata for container tags
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=ref,event=pr
            type=semver,pattern={{version}}
            type=semver,pattern={{major}}.{{minor}}
            type=semver,pattern={{major}}
            type=sha
            type=raw,value=latest,enable={{is_default_branch}}

      - name: Set container registry and image name
        run: |
          echo "CONTAINER_REGISTRY=${{ env.REGISTRY }}" >> $GITHUB_ENV
          echo "CONTAINER_IMAGE_NAME=${{ env.IMAGE_NAME }}" >> $GITHUB_ENV

      - name: Build and push container using .NET SDK
        run: |
          cd src/NuGetServer
          
          if [ "${{ github.event_name }}" == "pull_request" ]; then
            # For PRs, just build without pushing
            dotnet publish /t:PublishContainer \
              -p ContainerImageTag=pr-${{ github.event.number }}
          else
            # For main branch and tags, build and push with proper tagging
            # Get the main image name from metadata
            MAIN_TAG=$(echo "${{ steps.meta.outputs.tags }}" | head -n1)
            REPO_NAME=$(echo "$MAIN_TAG" | cut -d':' -f1)
            TAG_NAME=$(echo "$MAIN_TAG" | cut -d':' -f2)
            
            # Build and push with registry settings
            dotnet publish /t:PublishContainer \
              -p ContainerRegistry=${{ env.REGISTRY }} \
              -p ContainerRepository=$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]') \
              -p ContainerImageTag=${TAG_NAME}
            
            # Tag additional versions
            echo "${{ steps.meta.outputs.tags }}" | tail -n +2 | while read -r additional_tag; do
              if [ -n "$additional_tag" ]; then
                ADDITIONAL_TAG_NAME=$(echo "$additional_tag" | cut -d':' -f2)
                docker tag ${{ env.REGISTRY }}/$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]'):${TAG_NAME} ${{ env.REGISTRY }}/$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]'):${ADDITIONAL_TAG_NAME}
                docker push ${{ env.REGISTRY }}/$(echo "${{ env.IMAGE_NAME }}" | tr '[:upper:]' '[:lower:]'):${ADDITIONAL_TAG_NAME}
              fi
            done
          fi

      - name: Output container image details
        if: github.event_name != 'pull_request'
        run: |
          echo "Container images pushed:"
          echo "${{ steps.meta.outputs.tags }}"
